import { Meta, Story, Preview, Props } from '@storybook/addon-docs/blocks';

<Meta title="Examples/Grid View/README"/>

# Grid View Examples

This page provides various examples of customizing the GridView component.

<br/>

## Example - Custom toolbar action

This example shows how to add a custom action component into the gridView configuration that rendered in the grid toolbar.

### Steps

Implement custom component that prints "Hello World" underneath the grid.

```jsx
const withGridViewPrintAction = R.curry((WrappedGrid, props) => {
    const {id: gridId, defaultActions = []} = props;

    const [msg, updateMsg] = useState();

    const onRefreshHandler = () => updateMsg("Hello World");

    const _defaultActions = [
        ...defaultActions,
        <Tooltip title="Print" key={`${gridId}-print-action`} role="tooltip">
            <IconButton onClick={onRefreshHandler} role="button" aria-label="Refresh">
                <Print/>
            </IconButton>
        </Tooltip>,
    ];

    return (
        <>
            <WrappedGrid {...props} defaultActions={_defaultActions}/>

            <Typography variant="h1">{msg}</Typography>
        </>
    );
});
```

Implement a custom factory component for the GridView component where we add the custom action into the compose function.

```jsx
const GridViewFactory = (props) => {

    const ComposedGridView = R.compose(
        withGridViewConfigLoader,
        withGridViewDefaultActions,
        withGridViewActionExecutor,
        withCriteriaStateListener(null),
        withGridViewQueryLoader,
        withGridViewSorting,
        withGridViewSelection,
        withGridViewPagination,
        withGridViewPrintAction
    )(GridView);

    return (
        <ComposedGridView {...props}/>
    );
};
```

Create mapping conditions for the domain components.

```jsx
const DomainComponentMapping = R.cond([
    [R.propEq('type', 'grid'), GridViewFactory],
]);
```

Implement the domain component factory in the way that the domain component mapping comes first.

```jsx
const DomainComponentFactory = (props) => DomainComponentMapping(props) || DefaultComponentFactory(props)
```

<br/>

## Example - Custom column renderer

This example shows how to customize a Grid View component with adding a custom column rendering logic.

### Steps

Implement function for custom rendering value for a domain specific columns.
In the below snippet Material UI Alert component used as an example.

```jsx
	const renderStatus = R.curry((column, value) => {
		const {name} = column;
		const isCaseStatus = "case_status" === name;
		const severity = R.cond([
			[R.equals("Open"), R.always("info")],
			[R.equals("Error"), R.always("error")],
			[R.equals("Close"), R.always("success")],
			[R.T, R.always("warning")],
		])(value);

		const icon = isCaseStatus ? {icon: false} : {};
		return <Alert variant={isCaseStatus ? "filled" : "outlined"} severity={severity} {...icon}>{value}</Alert>;
	});
```

Implement a custom renderer function.

```jsx
	const domainStatusColumnRenderer = (value, row, column) => renderStatus(column, value);
```

Implement extension (HOC) for the grid that apply the custom renderer for a domain columns.

```jsx
	const withDomainColumnRendering = R.curry((WrappedGrid, props) => {
		const {columns = []} = props;
		const isDomainColumn = R.anyPass([R.propEq('name', 'case_status'), R.propEq('name', 'task_status')]);
		const domainStatusColumnMapper = R.when(isDomainColumn, column => ({
			...column,
			renderer: domainStatusColumnRenderer
		}));
		const _columns = R.map(domainStatusColumnMapper, columns);

		return <WrappedGrid {...props} columns={_columns}/>;
	});
```

Implement a custom factory component for the GridView component where we add withDomainColumnRendering HOC.

```jsx
const GridViewFactory = (props) => {

    const ComposedGridView = R.compose(
        withGridViewConfigLoader,
        withGridViewDefaultActions,
        withGridViewActionExecutor,
        withCriteriaStateListener(null),
        withGridViewQueryLoader,
        withGridViewSorting,
        withGridViewSelection,
        withGridViewPagination,
        withDomainColumnRendering
    )(GridView);

    return (
        <ComposedGridView {...props}/>
    );
};
```

Create mapping conditions for the domain components.

```jsx
const DomainComponentMapping = R.cond([
    [R.propEq('type', 'grid'), GridViewFactory],
]);
```

Implement the domain component factory in the way that the domain component mapping comes first.

```jsx
const DomainComponentFactory = (props) => DomainComponentMapping(props) || DefaultComponentFactory(props)
```

<br/>

## Example - Row double-click handler

This example shows how to customize a Grid View component with adding a custom row double-click handler.

### Steps

Implement default action template for redux store.

```jsx
const UPDATE_GRID_CURRENT_ACTION = "UPDATE_GRID_CURRENT_ACTION";

const updateGridCurrentAction = (id, currentAction) => ({
	type: UPDATE_GRID_CURRENT_ACTION,
	id, currentAction
});
```

Add custom row renderer and container with double-click handler support.

```jsx
const useCellRenderer = R.curry((classes, row, column) => {
		if (React.isValidElement(column)) {
			return (
				<TableCell key={`${row.id}-${column.props.name}`} className={classes.tableCell} scope="row" variant="body">
					{React.cloneElement(column, {row})}
				</TableCell>
			);
		}

		const value = row[column.name];

		const numeric = R.anyPass([
			R.propEq('dataType', 'int'),
			R.propEq('dataType', 'long'),
			R.propEq('dataType', 'number'),
			R.propEq('dataType', 'float')
		])(column);

		return (
			<TableCell key={`${row.id}-${column.name}`} className={classes.tableCell} scope="row" variant="body" align={numeric ? 'right' : 'left'}>
				{column.renderer ? column.renderer(value, row, column) : value}
			</TableCell>
		);
	});

	const CustomTableRowRenderer = (props) => {
		const {classes, columns, data, checked, disabled, enableSelection, onRowSelect, onRowDoubleClickAction} = props;

		const cellRenderer = useCellRenderer(classes, data);

		return (
			<TableRow aria-checked={checked} role="row" hover selected={checked} tabIndex={-1} onDoubleClick={() => onRowDoubleClickAction?.(data)}>
				{enableSelection &&
				<TableCell className={classes.tableCell} padding="checkbox">
					<Checkbox checked={checked}
							  disabled={disabled}
							  inputProps={{'aria-label': ' checkbox-' + data.id}}
							  onChange={() => onRowSelect && onRowSelect(data)}/>
				</TableCell>}

				{useMemo(() => R.addIndex(R.map)(cellRenderer, columns), [data, columns])}
			</TableRow>
		);
	};

	const TableRowContainer = (props) => {
		const {classes, idx, columns, data, checked, disabled, enableSelection, selected, onRowSelect, onRowDoubleClickAction, TableRowRenderer = CustomTableRowRenderer} = props;

		return useMemo(() => (
			<TableRowRenderer idx={idx}
							  classes={classes}
							  columns={columns}
							  data={data}
							  checked={checked}
							  disabled={disabled}
							  enableSelection={enableSelection}
							  onRowSelect={onRowSelect}
							  onRowDoubleClickAction={onRowDoubleClickAction}
			/>
		), [idx, columns, checked, disabled, data, enableSelection, selected, onRowDoubleClickAction]);
	};
```

Implement custom TableBodyRenderer and pass onRowDoubleClickAction to TableRowContainer

```jsx
const CustomTableBodyRenderer = (props) => {
		const {
			id: tableId,
			records = [],
			classes,
			columns,
			selected,
			enableSelection,
			onCheckPreselected,
			onRowSelect,
			TableRowRenderer,
			onRowDoubleClickAction
		} = props;

		const dispatch = useDispatch();

		return (
			<TableBody>
				{R.addIndex(R.map)((record, idx) => {
					const disabled = onCheckPreselected && onCheckPreselected(record.id);
					const checked = disabled || (selected && selected.some(s => s.id === record.id));

					return (
						<TableRowContainer key={`${record.id}-${idx}`}
										   idx={idx}
										   tableId={tableId}
										   classes={classes}
										   columns={columns}
										   checked={checked}
										   disabled={disabled}
										   data={record}
										   enableSelection={enableSelection}
										   selected={selected}
										   onRowSelect={onRowSelect}
										   TableRowRenderer={TableRowRenderer}
										   onRowDoubleClickAction={onRowDoubleClickAction && R.compose(dispatch, onRowDoubleClickAction)}
						/>
					);
				}, records)}
			</TableBody>
		);
	};
```

Create custom logic that uses store action template

```jsx
const withRowDoubleClickHandler = R.curry((actionName, WrappedGrid, props) => {
		const {id, actions} = props;
		const action = R.find(R.propEq("name", actionName), actions);

		return <WrappedGrid {...props} TableBodyRenderer={CustomTableBodyRenderer}
					 onRowDoubleClickAction={action ? selected => updateGridCurrentAction(id, {action, selected}) : undefined}/>;
	});
```

Implement a custom factory component for the GridView component where we add withRowDoubleClickHandler with "view" action argument.

```jsx
const GridViewFactory = (props) => {
		const ComposedGridView = R.compose(
			withGridViewConfigLoader,
			withGridViewSettings(defaultGridViewSettings),
			withGridViewDefaultActions,
			withGridViewModelBulkActions,
			withGridViewActionExecutor,
			withGridViewQueryLoader,
			withGridViewSorting,
			withGridViewSelection,
			withGridViewPagination,
			withRowDoubleClickHandler("view")
		)(GridView);

		return (
			<ComposedGridView {...props}/>
		);
	};
```

Create mapping conditions for the domain components.

```jsx
const DomainComponentMapping = R.cond([
    [R.propEq('type', 'grid'), GridViewFactory],
]);
```

Implement the domain component factory in the way that the domain component mapping comes first.

```jsx
const DomainComponentFactory = (props) => DomainComponentMapping(props) || DefaultComponentFactory(props)
```
