import { Meta, Story, Preview, Props } from '@storybook/addon-docs/blocks';

<Meta title="Examples/Grid View/README"/>

# Grid View Examples

This page provides various examples of customizing the GridView component.

<br/>

## Example - Custom toolbar action

This example shows how to add a custom action component into the gridView configuration that rendered in the grid toolbar.

### Steps

Implement custom component that prints "Hello World" underneath the grid.

```jsx
const withGridViewPrintAction = R.curry((WrappedGrid, props) => {
    const {id: gridId, defaultActions = []} = props;

    const [msg, updateMsg] = useState();

    const onRefreshHandler = () => updateMsg("Hello World");

    const _defaultActions = [
        ...defaultActions,
        <Tooltip title="Print" key={`${gridId}-print-action`} role="tooltip">
            <IconButton onClick={onRefreshHandler} role="button" aria-label="Refresh">
                <Print/>
            </IconButton>
        </Tooltip>,
    ];

    return (
        <>
            <WrappedGrid {...props} defaultActions={_defaultActions}/>

            <Typography variant="h1">{msg}</Typography>
        </>
    );
});
```

Extend default GridView component with withGridViewPrintAction HOC

```jsx
const Component = withGridViewPrintAction(GridView);
```

Create mapping conditions for the domain components.

```jsx
const DomainComponentMapping = R.cond([
    [R.propEq('type', 'grid'), (props) => <DefaultGridViewFactory {...props} Component={Component}/>],
]);
```

Implement the domain component factory in the way that the domain component mapping comes first.

```jsx
const DomainComponentFactory = (props) => DomainComponentMapping(props) || DefaultComponentFactory(props)
```

<br/>

## Example - Custom toolbar bulk action with configured view

This example shows how to add custom action with configurable via solution file view to a Grid View component.

### Steps

We're going to add custom `Verify` action to a toolbar. To do that first of all define a conditional logic, which 
allows to detect our new action:

```jsx 
    const isVerifyAction = R.allPass([R.propEq('type', 'custom.verify'), isDocument]);
``` 

In code snippet above it checks, that action's `resourceName` property equals `documents` and it's `type` 
is `custom.verify`.

Implement form submit handler for `Verify` action:

```jsx 
	const VerifyFormSubmitHandler = (props) => {
		const {actionLink, data, fields = {}, selected} = props;

		const parsedFormData = parseFormData(data, fields);

		const payload = {ids: selected.map(s => s.id), formData: parsedFormData};

		return actionLink && submitRequest(actionLink, payload, 'POST');
	};
```

This handler will generate a payload with `ids` and `formData` keys, where `ids` is an array, which contains selected 
records ids, and `formData` is a form data containing object. Created payload will be sent to action execution link, 
i.e. action's href.

Customize DefaultFormSubmitHandlerMapper by adding condition for `Verify` action:

```jsx
	const DomainFormSubmitHandlerMapper = R.cond([
		[isVerifyAction, R.always(VerifyFormSubmitHandler)],
		[R.T, DefaultFormSubmitHandlerMapper]
	]);
``` 

Define headless handler for Verify action. It is executed if `view` link hasn't been returned for some reason.

```jsx
	const VerifyHeadlessBulkAction = (props) => {
		const {action, selected, onSuccess, onError} = props;

		useEffect(() => {
			const ids = Array.isArray(selected) ? selected.map(s => s.id) : [selected.id];

			const payload = {ids, formData: {}};

			action.href && submitRequest(action.href, payload, 'POST').then(onSuccess).catch(onError);
		}, []);

		return null;
	};
```

Similarly to VerifyFormSubmitHandler it creates a payload with `ids` and `formData` keys. Since for this particular case 
we don't have a view, `formData` object is empty. Payload will be sent to action execution link, i.e. action's href.

Implement `Verify` action:

```jsx
	const VerifyAction = (props) => withActionView({
		...props,
		title: "Verify",
		submitLabel: "Verify",
		ViewForm: R.compose(withFormCleanup, withFormSubmitAction)(DefaultViewForm),
		viewLinkFn: ({_links: actionLinks}, objLinks) => getLinkByRel(objLinks, 'view') || getLinkByRel(actionLinks, 'view'),
	}, withActionBackdrop(VerifyHeadlessBulkAction));
```

`withActionView` function uses 2 arguments. The first one contains some action view properties, like `title`, 
`submitLabel`, `ViewForm` (in code snippet above it's a DefaultViewForm, wrapped with 2 functions: withFormCleanup and
withFormSubmitAction), `viewLinkFn`. Second argument is a handler for case when evaluated by `viewLinkFn` function
`view` link is empty by some reason.

Example of `withFormCleanup` function, that allows to cleanup form after component is unmounted:

```jsx
	const {formId} = props;
	const dispatch = useDispatch();
	const cleanup = () => dispatch(clearFormState(formId));

	useEffect(() => {
		return cleanup;
	}, []);

	return <WrappedComponent {...props}/>;
```

As an option you may redeclare `onSuccess` and `onClose` functions inside `withFormCleanup` function 
(instead of `useEffect` hook), so that form isn't cleared when server returns error.

Customize DefaultActionMapper by adding extra condition for `Verify` action:

```jsx
	const DomainActionMapper = R.curry((settings = {}, action) => {
		return R.cond([
			[isVerifyAction, R.always(VerifyAction(settings))],
			[R.T, action => DefaultActionMapper(settings, action)],
		])(action);
	});
```

Create an action factory component by passing created above action mapper and form submit handler 
mapper into a constructor:

```jsx
	const ActionFactory =
		new DefaultActionFactory(actionFactoryConfig, DomainActionMapper, DomainFormSubmitHandlerMapper);
```

<br/>

## Example - Custom toolbar bulk action with own view

This example shows how to add custom action with own view to a Grid View component.

### Steps

We're going to add custom `Verify` action to a toolbar. To do that first of all define a conditional logic, which 
allows to detect our new action:

```jsx 
    const isVerifyAction = R.allPass([R.propEq('type', 'custom.verify'), isDocument]);
``` 

In code snippet above it checks, that action's `resourceName` property equals `documents` and it's `type` 
is `custom.verify`.

Implement form submit handler for `Verify` action:

```jsx 
	const VerifyFormSubmitHandler = (props) => {
		const {actionLink, data, fields = {}, selected} = props;

		const formData = parseFormData(data, fields);

		const payload = {ids: selected.map(s => s.id), formData};

		return actionLink && submitRequest(actionLink, payload, 'POST');
	};
```

This handler will generate a payload with `ids` and `formData` keys, where `ids` is an array, which contains selected 
records ids, and `formData` is a form data containing object. Created payload will be sent to action execution link, 
i.e. action's href.

Customize DefaultFormSubmitHandlerMapper by adding condition for `Verify` action:

```jsx
	const DomainFormSubmitHandlerMapper = R.cond([
		[isVerifyAction, R.always(VerifyFormSubmitHandler)],
		[R.T, DefaultFormSubmitHandlerMapper]
	]);
``` 

Implement a view for `Verify` action:

```jsx
	const VerifyViewForm = (props) => {
		const {classes, formId, actions, loading, FieldComponent = FormField} = props;

		const dispatch = useDispatch();
		const formData = useSelector(R.path(["forms", formId, 'data']));

		useEffect(() => {
			const data = {age: {type: 'range', name: 'range', label: 'Age', value: [18, 60]}};
			dispatch(updateFormState(formId, {data, objLinks: {}}));
		}, []);

		return (<>
			<div className={classes.root}>

				{actions && actions.length > 0 &&
				  <Toolbar role="toolbar">
					{loading && <div style={{width: '100%'}}><LinearProgress color="primary"/></div>}
					{!loading && <div style={{flex: '1 1'}}/>}
					{!loading && actions}
				</Toolbar>}

				<div className={classes.content}>
					<Typography display='block' variant="subtitle2" color='textPrimary'>
						Specified age range: {`${R.path(['age', 'value', 0], formData)} - ${R.path(['age', 'value', 1], formData)}`} <sup>1</sup>
					</Typography>
					<form id={formId} noValidate role="form" aria-label="Details View">
						<FieldComponent {...R.prop('age', formData)} formatValue={x => `${x} years`}
										data={[{value: 0}, {value: 18}, {value: 25}, {value: 35}, {value: 45}, {value: 60}, {value: 99}]}
										formatValue={x => `${x} years`}
										onChange={(value) => dispatch(updateFieldValue(formId, 'age', value))}/>
					</form>
					<Typography display='block' variant="body2" color='textSecondary' mt={3}>
						<p><sup>1</sup>A business must identify and understand its target audience if their marketing campaign is
							to be successful. It allows the business to craft their products or services to the wants
							and needs of customers, in order to maximise sales and therefore revenue.
							A successful marketing campaign connects with consumers on a personal dB level, which will
							help the business to develop long-term relationships with customers (Sherlock, 2014).
						</p>

						<p>Not all consumers are the same. Determining the target audience is key to reaching the loyal
							and high-profit customers, in order to ensure a return on investment (Cahill, 1997, p. 10-11).
						</p>

						<p>To determine the target audience, the business must first identify what problem their
							product or service solves, or what need or want it fulfills (Sherlock, 2014).
							The problem must be one that consumers are aware of and thus will be interested in solving.
						</p>
					</Typography>
				</div>
			</div>
		</>)
	};
```

The form contains submit button, slider component to specify age range for the action and some text. 
The form is initialized with following value for slider field - [18, 60] and uses `forms` store to keep and 
retrieve `age` field values.

Implement `Verify` action:

```jsx
	const VerifyAction = (props) => withActionView({
		...props,
		title: "Verify",
		submitLabel: "Verify",
		ViewForm: R.compose(withFormSubmitAction, withStyles(styles))(VerifyViewForm),
	}, () => null);
```

`withActionView` function uses 2 arguments. 

First argument contains action view properties, like `title`, `submitLabel` and `ViewForm`. `ViewForm` uses defined 
above `VerifyViewForm` with 2 HOCs. Wrapping view with `withFormSubmitAction` function adds some extra logic 
for submit button. `withStyles` HOC allows to add some extra styling; example for `styles` attribute is in the 
snippet below:

```jsx
	const styles = (theme) => ({
		root: {
			width: '100%',
		},
		content: {
			marginTop: theme.spacing(2)
		},
	});
```

The second argument of `withActionView` is just a function which returns `null`: there is no need to specify a 
headless handler since no way we haven't view for the action. 

Customize DefaultActionMapper by adding extra condition for `Verify` action:

```jsx
	const DomainActionMapper = R.curry((settings = {}, action) => {
		return R.cond([
			[isVerifyAction, R.always(VerifyAction(settings))],
			[R.T, action => DefaultActionMapper(settings, action)],
		])(action);
	});
```

Create an action factory component by passing created above action mapper and form submit handler 
mapper into a constructor:

```jsx
	const ActionFactory =
		new DefaultActionFactory(actionFactoryConfig, DomainActionMapper, DomainFormSubmitHandlerMapper);
```

<br/>

## Example - Custom toolbar bulk actions

This example shows how to replace default bulk actions renderer with custom one for a Grid View component.
Sometimes it can be useful if for example only custom bulk action is configured and selected records don't have a corresponding link.

### Steps

We well be using the same action `Verify` action from the [Example - Custom toolbar bulk action with configured view](#example---custom-toolbar-bulk-action-with-configured-view)
but with custom bulk actions rendering logic. To render custom bulk actions we create High Ordered Component (HOC) for the grid
and replace default bulk actions with Button component for `custom.verify` action type:
```jsx
const withGridCustomBulkAction = R.curry((WrappedGrid, props) => {
	const {actions = [], id} = props;

	const dispatch = useDispatch();

	const selected = useSelector(R.path(["grids", id, "selected"]));

	const handleActionClick = (action, selected = []) => {
		dispatch(grids.updateGridCurrentAction(id, {action, selected}));
	};

	const customAction = R.find(R.propEq("type", "custom.verify"), actions);

	const bulkActions = customAction ? [
		<Button
			name={customAction.name}
			variant="contained"
			size="medium"
			color="primary"
			tabIndex="0"
			onClick={() => handleActionClick(customAction, selected)} role="button">
			{customAction.label}
		</Button>
	] : [];

	return <WrappedGrid {...props} bulkActions={bulkActions}/>;
});
```
Extend default GridView component with withGridCustomBulkAction HOC

```jsx
const Component = withGridViewPrintAction(GridView);
```

Create mapping conditions for the domain components.

```jsx
const DomainComponentMapping = R.cond([
    [R.propEq('type', 'grid'), (props) => <DefaultGridViewFactory {...props} Component={Component}/>],
]);
```

Implement the domain component factory in the way that the domain component mapping comes first.

```jsx
const DomainComponentFactory = (props) => DomainComponentMapping(props) || DefaultComponentFactory(props)
```

<br/>

## Example - Custom column renderer

This example shows how to customize a Grid View component with adding a custom column rendering logic.

### Steps

Implement function for custom rendering value for a domain specific columns.
In the below snippet Material UI Alert component used as an example.

```jsx
	const renderStatus = R.curry((column, value) => {
		const {name} = column;
		const isCaseStatus = "case_status" === name;
		const severity = R.cond([
			[R.equals("Open"), R.always("info")],
			[R.equals("Error"), R.always("error")],
			[R.equals("Close"), R.always("success")],
			[R.T, R.always("warning")],
		])(value);

		const icon = isCaseStatus ? {icon: false} : {};
		return <Alert variant={isCaseStatus ? "filled" : "outlined"} severity={severity} {...icon}>{value}</Alert>;
	});
```

Implement a custom renderer function.

```jsx
	const domainStatusColumnRenderer = (value, row, column) => renderStatus(column, value);
```

Implement useDomainColumnRenderer hook to domainStatusColumnRenderer for status columns or default for others.

```jsx
const useDomainColumnRenderer = R.cond([
    [isCaseStatusColumn, R.always(domainStatusColumnRenderer)],
    [R.T, useDefaultColumnRenderer]
]);
```

Create mapping conditions for the domain grid component and pass custom useColumnRenderer to DefaultGridViewFactory.

```jsx
    const DomainComponentMapping = R.cond([
        [R.propEq('type', 'grid'), (props) => <DefaultGridViewFactory {...props}
                                                                      useColumnRenderer={useDomainColumnRenderer}/>],
    ]);
```

Implement the domain component factory in the way that the domain component mapping comes first.

```jsx
const DomainComponentFactory = (props) => DomainComponentMapping(props) || DefaultComponentFactory(props)
```

<br/>

## Example - Custom column action

This example shows how to customize a Grid View component with adding a custom column action logic.

### Steps

Implement custom column action mapper for gender column.

```jsx
const mappedColumnName = 'gender';
const useColumnActionType = R.cond([[R.propEq('name', mappedColumnName), R.always('download')]]);
```

Create a custom renderer and use it for gender column to indicate custom action.

```jsx
const customActionRenderer = R.curry((column) => {
			return (value, record, column) => {
				const handleClick = (event) => {
					event.preventDefault();
					column.onClick && column.onClick(record);
				};
				return <Tooltip title={column.label} role="tooltip">
					<GetAppIcon cursor='pointer' color="inherit" onClick={handleClick}/>
				</Tooltip>;
			};
		});
const useColumnRenderer = column => R.cond([[R.propEq('name', mappedColumnName), customActionRenderer]])(column) || useDefaultColumnRenderer(column);
```

Implement extension (HOC) for the grid to put changes above together.

```jsx
const withCustomColumnActionType = R.curry((WrappedGrid, props) => {
		return <WrappedGrid {...props} useColumnActionType={useColumnActionType} useColumnRenderer={useColumnRenderer} />;
	});
```

Create mapping conditions for the domain grid component and pass custom useColumnActionType and useColumnRenderer to DefaultGridViewFactory.

```jsx
const DomainComponentMapping = R.cond([
    [R.propEq('type', 'grid'),
        (props) => <DefaultGridViewFactory {...props} useColumnActionType={useColumnActionType}
                                           useColumnRenderer={useColumnRenderer}/>],
]);
```

Implement the domain component factory in the way that the domain component mapping comes first.

```jsx
const DomainComponentFactory = (props) => DomainComponentMapping(props) || DefaultComponentFactory(props)
```

<br/>

## Example - Row double-click handler

This example shows how to customize a Grid View component with adding a custom row double-click handler.

### Steps

Create custom logic that passes useCustomCellRenderer with implemented view action on any column double-click to GridView props.

```jsx
const findCustomAction = actionName => R.find(R.propEq("name", actionName));
const withUseCustomCellRenderer = R.curry((WrappedGrid, props) => {
	const {id, actions} = props;
	const dispatch = useDispatch();
	const action = findCustomAction('view')(actions);
	const useCustomCellRenderer = R.curry((classes, row, column) => {
		const value = row[column.name];
		return (
			<TableCell onDoubleClick={() => dispatch(grids.updateGridCurrentAction(id, {action, selected: row}))} key={`${row.id}-${column.name}`} className={classes.tableCell} scope="row" variant="body">
				{column.renderer ? column.renderer(value, row, column) : value}
			</TableCell>
		);
	});
	return <WrappedGrid {...props} useCellRenderer={useCustomCellRenderer}/>;
});
```

Extend default GridView component with withUseCustomCellRenderer HOC

```jsx
const Component = withGridViewPrintAction(GridView);
```

Create mapping conditions for the domain components.

```jsx
const DomainComponentMapping = R.cond([
    [R.propEq('type', 'grid'), (props) => <DefaultGridViewFactory {...props} Component={Component}/>],
]);
```

Implement the domain component factory in the way that the domain component mapping comes first.

```jsx
const DomainComponentFactory = (props) => DomainComponentMapping(props) || DefaultComponentFactory(props)
```
