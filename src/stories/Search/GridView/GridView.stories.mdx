import {Meta} from '@storybook/addon-docs/blocks';

<Meta title="Examples/Search/Grid/README"/>

# Grid View Customization Examples

This page shows various ways for customizing the default Grid View component.

<br/>

## Example - Using a custom grid toolbar action

This example shows how to add a custom action component that will be rendered in the grid toolbar.

### Steps

Implement custom component that prints "Hello World" underneath the grid.

```jsx
const withGridViewPrintAction = R.curry((WrappedGrid, props) => {
    const {id: gridId, defaultActions = []} = props;

    const [msg, updateMsg] = useState();

    const onRefreshHandler = () => updateMsg("Hello World");

    const _defaultActions = [
        ...defaultActions,
        <Tooltip title="Print" key={`${gridId}-print-action`} role="tooltip">
            <IconButton onClick={onRefreshHandler} role="button" aria-label="Refresh">
                <Print/>
            </IconButton>
        </Tooltip>,
    ];

    return (
        <>
            <WrappedGrid {...props} defaultActions={_defaultActions}/>

            <Typography variant="h1">{msg}</Typography>
        </>
    );
});
```

Extend the default GridView component with withGridViewPrintAction high-order function and pass it to the GridView factory component.

```jsx
const Component = withGridViewPrintAction(GridView);

<DefaultGridViewFactory Component={Component}/>
```

<br/>

## Example - Using a custom grid bulk action with default view

This example shows how to add custom action with the view configured via the solution file.

### Steps

We're going to add custom `Verify` action to a toolbar. To do that first of all define a conditional logic, which
allows to detect our new action:

```jsx 
const isVerifyAction = R.allPass([R.propEq('type', 'custom.verify'), isDocument]);
``` 

In code snippet above it checks, that action's `resourceName` property equals `documents` and it's `type`
is `custom.verify`.

Implement form submit handler for `Verify` action:

```jsx 
const VerifyFormSubmitHandler = (props) => {
	const {actionLink, data, fields = {}, selected} = props;

	const parsedFormData = parseFormData(data, fields);

	const payload = {ids: selected.map(s => s.id), formData: parsedFormData};

	return actionLink && submitRequest(actionLink, payload, 'POST');
};
```

This handler will generate a payload with `ids` and `formData` keys, where `ids` is an array, which contains selected
records ids, and `formData` is a form data containing object. Created payload will be sent to action execution link,
i.e. action's href.

Customize DefaultFormSubmitHandlerMapper by adding condition for `Verify` action:

```jsx
	const DomainFormSubmitHandlerMapper = R.cond([
		[isVerifyAction, R.always(VerifyFormSubmitHandler)],
		[R.T, DefaultFormSubmitHandlerMapper]
	]);
``` 

Define headless handler for Verify action. It is executed if `view` link hasn't been returned for some reason.

```jsx
	const VerifyHeadlessBulkAction = (props) => {
		const {action, selected, onSuccess, onError} = props;

		useEffect(() => {
			const ids = Array.isArray(selected) ? selected.map(s => s.id) : [selected.id];

			const payload = {ids, formData: {}};

			action.href && submitRequest(action.href, payload, 'POST').then(onSuccess).catch(onError);
		}, []);

		return null;
	};
```

Similarly to VerifyFormSubmitHandler it creates a payload with `ids` and `formData` keys. Since for this particular case
we don't have a view, `formData` object is empty. Payload will be sent to action execution link, i.e. action's href.

Implement `Verify` action:

```jsx
	const VerifyAction = (props) => withActionView({
		...props,
		title: "Verify",
		submitLabel: "Verify",
		ViewForm: R.compose(withFormCleanup, withFormSubmitAction)(DefaultViewForm),
		viewLinkFn: ({_links: actionLinks}, objLinks) => getLinkByRel(objLinks, 'view') || getLinkByRel(actionLinks, 'view'),
	}, withActionBackdrop(VerifyHeadlessBulkAction));
```

`withActionView` function uses 2 arguments. The first one contains some action view properties, like `title`,
`submitLabel`, `ViewForm` (in code snippet above it's a DefaultViewForm, wrapped with 2 functions: withFormCleanup and
withFormSubmitAction), `viewLinkFn`. Second argument is a handler for case when evaluated by `viewLinkFn` function
`view` link is empty by some reason.

Example of `withFormCleanup` function, that allows to cleanup form after component is unmounted:

```jsx
	const {formId} = props;
	const dispatch = useDispatch();
	const cleanup = () => dispatch(clearFormState(formId));

	useEffect(() => {
		return cleanup;
	}, []);

	return <WrappedComponent {...props}/>;
```

As an option you may redeclare `onSuccess` and `onClose` functions inside `withFormCleanup` function
(instead of `useEffect` hook), so that form isn't cleared when server returns error.

Customize DefaultActionMapper by adding extra condition for `Verify` action:

```jsx
	const DomainActionMapper = R.curry((settings = {}, action) => {
		return R.cond([
			[isVerifyAction, R.always(VerifyAction(settings))],
			[R.T, action => DefaultActionMapper(settings, action)],
		])(action);
	});
```

Create an action factory component by passing created above action mapper and form submit handler
mapper into a constructor:

```jsx
	const ActionFactory =
		new DefaultActionFactory(settings, DomainActionMapper, DomainFormSubmitHandlerMapper);
```

<br/>

## Example - Using a custom grid bulk action with a custom view

This example shows how to add a custom action with the custom view configuration.

### Steps

We're going to add custom `Verify` action to a toolbar. To do that first of all define a conditional logic, which
allows to detect our new action:

```jsx 
    const isVerifyAction = R.allPass([R.propEq('type', 'custom.verify'), isDocument]);
``` 

In code snippet above it checks, that action's `resourceName` property equals `documents` and it's `type`
is `custom.verify`.

Implement form submit handler for `Verify` action:

```jsx 
	const VerifyFormSubmitHandler = (props) => {
		const {actionLink, data, fields = {}, selected} = props;

		const formData = parseFormData(data, fields);

		const payload = {ids: selected.map(s => s.id), formData};

		return actionLink && submitRequest(actionLink, payload, 'POST');
	};
```

This handler will generate a payload with `ids` and `formData` keys, where `ids` is an array, which contains selected
records ids, and `formData` is a form data containing object. Created payload will be sent to action execution link,
i.e. action's href.

Customize DefaultFormSubmitHandlerMapper by adding condition for `Verify` action:

```jsx
	const DomainFormSubmitHandlerMapper = R.cond([
		[isVerifyAction, R.always(VerifyFormSubmitHandler)],
		[R.T, DefaultFormSubmitHandlerMapper]
	]);
``` 

Implement a view for `Verify` action:

```jsx
	const VerifyViewForm = (props) => {
		const {classes, formId, actions, loading, FieldComponent = FormField} = props;

		const dispatch = useDispatch();
		const formData = useSelector(R.path(["forms", formId, 'data']));

		useEffect(() => {
			const data = {age: {type: 'range', name: 'range', label: 'Age', value: [18, 60]}};
			dispatch(updateFormState(formId, {data, objLinks: {}}));
		}, []);

		return (<>
			<div className={classes.root}>

				{actions && actions.length > 0 &&
				  <Toolbar role="toolbar">
					{loading && <div style={{width: '100%'}}><LinearProgress color="primary"/></div>}
					{!loading && <div style={{flex: '1 1'}}/>}
					{!loading && actions}
				</Toolbar>}

				<div className={classes.content}>
					<Typography display='block' variant="subtitle2" color='textPrimary'>
						Specified age range: {`${R.path(['age', 'value', 0], formData)} - ${R.path(['age', 'value', 1], formData)}`} <sup>1</sup>
					</Typography>
					<form id={formId} noValidate role="form" aria-label="Details View">
						<FieldComponent {...R.prop('age', formData)} formatValue={x => `${x} years`}
										data={[{value: 0}, {value: 18}, {value: 25}, {value: 35}, {value: 45}, {value: 60}, {value: 99}]}
										formatValue={x => `${x} years`}
										onChange={(value) => dispatch(updateFieldValue(formId, 'age', value))}/>
					</form>
					<Typography display='block' variant="body2" color='textSecondary' mt={3}>
						<p><sup>1</sup>A business must identify and understand its target audience if their marketing campaign is
							to be successful. It allows the business to craft their products or services to the wants
							and needs of customers, in order to maximise sales and therefore revenue.
							A successful marketing campaign connects with consumers on a personal dB level, which will
							help the business to develop long-term relationships with customers (Sherlock, 2014).
						</p>

						<p>Not all consumers are the same. Determining the target audience is key to reaching the loyal
							and high-profit customers, in order to ensure a return on investment (Cahill, 1997, p. 10-11).
						</p>

						<p>To determine the target audience, the business must first identify what problem their
							product or service solves, or what need or want it fulfills (Sherlock, 2014).
							The problem must be one that consumers are aware of and thus will be interested in solving.
						</p>
					</Typography>
				</div>
			</div>
		</>)
	};
```

The form contains submit button, slider component to specify age range for the action and some text.
The form is initialized with following value for slider field - [18, 60] and uses `forms` store to keep and
retrieve `age` field values.

Implement `Verify` action:

```jsx
	const VerifyAction = (props) => withActionView({
		...props,
		title: "Verify",
		submitLabel: "Verify",
		ViewForm: R.compose(withFormSubmitAction, withStyles(styles))(VerifyViewForm),
	}, () => null);
```

`withActionView` function uses 2 arguments.

First argument contains action view properties, like `title`, `submitLabel` and `ViewForm`. `ViewForm` uses defined
above `VerifyViewForm` with 2 HOCs. Wrapping view with `withFormSubmitAction` function adds some extra logic
for submit button. `withStyles` HOC allows to add some extra styling; example for `styles` attribute is in the
snippet below:

```jsx
	const styles = (theme) => ({
		root: {
			width: '100%',
		},
		content: {
			marginTop: theme.spacing(2)
		},
	});
```

The second argument of `withActionView` is just a function which returns `null`: there is no need to specify a
headless handler since no way we haven't view for the action.

Customize DefaultActionMapper by adding extra condition for `Verify` action:

```jsx
	const DomainActionMapper = R.curry((settings = {}, action) => {
		return R.cond([
			[isVerifyAction, R.always(VerifyAction(settings))],
			[R.T, action => DefaultActionMapper(settings, action)],
		])(action);
	});
```

Create an action factory component by passing created above action mapper and form submit handler
mapper into a constructor:

```jsx
	const ActionFactory =
		new DefaultActionFactory(settings, DomainActionMapper, DomainFormSubmitHandlerMapper);
```

<br/>

## Example - Custom a custom grid column renderer

This example shows how to customize a Grid View component with adding a custom column rendering logic.

### Steps

Implement a function for custom value rendering for a specific grid column.

```jsx
const renderGender = R.curry((column, value) => {
	if (R.isEmpty(value) || R.isNil(value)) {
		return null;
	}

	const color = R.cond([
		[R.equals("Male"), R.always(amber[500])],
		[R.equals("Female"), R.always(purple[500])],
	])(value);

	return <Avatar style={{color}}>{value.charAt(0)}</Avatar>;
});
```

Implement a custom renderer function.

```jsx
const useGenderColumnRenderer = (column) => (value, row) => R.compose(renderGender(column), mapValue)(value);
```

Implement the custom column rendering hook - useDomainColumnRenderer.

This hook should be passed as a property value for the useColumnRenderer property.

```jsx
const isGenderColumn = R.anyPass([R.propEq('name', 'gender')]);

const useDomainColumnRenderer = R.cond([
	[isGenderColumn, useGenderColumnRenderer],
	[R.T, useDefaultColumnRenderer]
]);

<DefaultGridViewFactory useColumnRenderer={useDomainColumnRenderer}/>

```

<br/>

## Example - Using a custom grid column action

This example shows how to customize the default GridView component by adding a custom column action logic.

### Steps

Create a custom column rendering function and use it for mapping the gender column to indicate a custom action.

This hook should be passed as a property value for the useColumnRenderer property.

```jsx
const useCustomActionRenderer = (column) => (value, row) => {
	const handleClick = (event) => {
		event.preventDefault();

		alert("Gender Lookup");
	};

	return (
		<Box display="flex" flexWrap="noWrap" alignItems="center" justifyContent="center">
			<Box>
				<Typography variant="subtitle2">
					{column.label}
				</Typography>
			</Box>
			<Box mx={2}>
				<PageviewIcon cursor='pointer' color="inherit" onClick={handleClick}/>
			</Box>
		</Box>
	);
};

// eslint-disable-next-line react-hooks/rules-of-hooks
const useColumnRenderer = R.cond([
	[R.propEq('name', 'gender'), useCustomActionRenderer],
	[R.T, useDefaultColumnRenderer]
]);

<DefaultGridViewFactory useColumnRenderer={useColumnRenderer}/>

```
<br/>

## Example - Using a custom grid column click handler

This example shows how to customize the default GridView component by adding a custom cell handler.

### Steps

Create a high-order component that implements the cell double-click logic.
Use this custom component to extend the default grid component.

```jsx
const withCustomCellHandler = R.curry((WrappedGrid, props) => {
	const findAction = actionName => R.find(R.propEq("name", actionName));

	const {id, actions} = props;

	const dispatch = useDispatch();

	const action = findAction('view')(actions);

	const useCustomCellRenderer = R.curry((classes, row, column) => {

		const value = row[column.name];

		return (
			<TableCell key={`${row.id}-${column.name}`}
			           className={classes.tableCell}
			           scope="row"
			           variant="body"
			           onDoubleClick={() => dispatch(grids.updateGridCurrentAction(id, {action, selected: row}))}
			>
				{column.renderer ? column.renderer(value, row, column) : value}
			</TableCell>
		);
	});

	return (
		<WrappedGrid {...props} useCellRenderer={useCustomCellRenderer}/>
	);
});

<DefaultGridViewFactory Component={DomainGridView}/>

```